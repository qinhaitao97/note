---
title: 作用域
date: 2018-05-03 09:13:14
updated:
categories:
  - JavaScript
tags:
  - JavaScript
top: false
comments:
keywords:
description: " "
---

![](https://ws1.sinaimg.cn/large/006eYMu7ly1fu9ljbikppj30el09lq3s.jpg)

# 作用域

## 是什么

作用域是代码运行时，各个变量、函数和对象的可访问性；作用域决定了代码里中变量和其他资源的生命周期及在各个地区中的可见性

## 为什么

为什么要设置作用域的概念，作用域可以为代码提供一个安全的层级，在计算机中一个常规的原则就是，用户只能访问他们当前需要的东西；作用域还可以帮助我们提升性能，追踪bug减少bug；还可以解决不同范围同名变量冲突的问题

## 分类

JavaScript 中的变量的作用域分为全局作用域和局部作用域；而对于JavaScript来说，它采用的是词法作用域，也可以说是静态作用域，JavaScript不采用动态作用域，但是 `this` 的运行机制和动态作用域相似；在 ES6 规范声明后，可以用 `let` 代替 `var`，将局部作用域声明为块级作用域

```
- 全局作用域
- 局部作用域
- 词法作用域
- 动态作用域
- 块级作用域
```

### 全局作用域

全局变量、即在函数外声明的变量具有全局作用域，全局作用域中的变量生命周期应与整个程序相同；全局作用域中的变量能被其他的方法访问

### 局部作用域

局部变量、即在函数方法题内声明的变量具有局部作用域，局部变量声明周期应与其所在的方法相同；局部作用域中的变量能被其子作用域访问

### 词法作用域

JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了

```js
var x = 1;
function foo() {
    console.log(x);
}

function test() {
    var x = 2;
    foo();
}
test();     // 1
```

词法作用域，此处输出 1 ，动态作用域，此处输出 2 ，JavaScript采用词法作用域，所以这里输出 1 ，至于为什么，讲完后面的的知识，会更好理解

### 动态作用域

动态作用域与词法作用域相对，函数的作用域在调用的时候才决定，JavaScript 中采用的是词法作用域，但是JavaScript 中 `this` 的执行机制和动态作用域很相似

### 块级作用域

ES6 规范允许使用 `let` 关键字，声明块级作用域，块级作用域不再允许其他作用域的访问



# 执行上下文

回想上一个文章中讲到的关于预编译的知识，在 JS 执行和方法执行的前一刻，系统会分别创建 VO 和 AO 对象，这个 VO 和 AO 对象就是(刚刚创建的)执行期上下文。执行期上下文包括了预编译的内容，也包括代码执行时对执行期上下文的修改，它就是 js 或者 函数在运行时的作用域



# 执行上下文堆栈

浏览器里面的 JavaScript 解释器是单线程，同一时间只能发生一件事，其他行为会被放到执行堆栈里面排队，因此，在浏览器首次载入脚本时，将直接创建全局的执行上下文对象，将此对象压入栈底，当有函数执行时，将该函数的执行上下文压入栈中，浏览器总会执行栈顶的执行上下文，一旦当前执行上下文函数执行结束，他将被从栈顶抛出，将执行上下文的控制权交给当前的栈顶元素，直至执行堆栈中剩全局执行上下文为止

```
敲黑板：
	- 单线程
	- 同步执行
	- 栈底全局执行上下文
	- 可变的函数执行上下文
	- 执行上下文不同于上下文，关于上下文的讲解后面的文章介绍
```



# 作用域链

在执行上下文堆栈中，每一个栈元素(执行上下文)都是一个作用域，他们构成的链式的结构，便是作用域链，下面一个实例来描述这个过程

```js
  function a() {

    function b() {

      function c() {}

      c();
    }
    b();
  }
  a();
```

```js
// 每个函数的作用域链的产生过程
// a defined a.[[scope]] ---> 0 : VO		a 函数定义时，执行上下文堆栈中中的情况
// a doing   a.[[scope]] ---> 0 : aAO		a 函数执行前(时)，执行上下文堆栈的情况，下同
//                            1 : VO

// b defined b.[[scope]] ---> 0 : aAO
//                            1 : VO
// b doing   b.[[scope]] ---> 0 : bAO
//                            1 : aAO
//                            2 : VO

// c defined c.[[scope]] ---> 0 : bAO
//                            1 : aAO
//                            2 : VO
// c doing c.[[scope]] --->   0 : cAO
//                            1 : bAO
//                            2 : aAO
//                            3 : VO
```



# 执行上下文创建

包括两部分，预编译部分和代码执行部分，预编译部分除了上一文章中提到的操作以外，还包括一个确定 this 指向，在预编译过程中，this 始终指向 window，在代码执行过程中，this 指向调用它的对象



# 词法作用域深究

从作用域链的角度来讲，某一个执行上下文的词法作用域是当前执行上下文中它的下一个执行上下文，还是以之前的那段代码为例

```js
var x = 1;
function foo() {
    console.log(x);
}

function test() {
    var x = 2;
    foo();
}
test();     // 1
```

```js
// foo 函数的执行上下文堆栈
	// foo.AO(栈顶) --- VO(栈底)
	// foo.AO 执行上下文中没有 x，就向它的词法作用域中寻找，它的词法作用域是 foo.AO 的下面一个执行上下	   // 文，即 VO，VO 中存在 x 且值为 1，所以打印结果为 1
```



# 立即执行函数

## 定义

立即执行函数没有函数声明，定义后立即执行，执行完毕后即释放，适合做初始化工作

## 形式

```js
(function (pram) {})(pram);
```

## 说明

+ 以上定义形式只是 W3C 标准建议的声明形式，还有其他的声明形式
+ 立即执行函数可以写函数名，但是因为它立即执行并执行完释放的特点，函数名没有什么用，所以一般不写
+ 除了声明形式和执行机制以外，其他和普通函数一样
+ 立即执行函数的实参写在最后的括号内



> 立即执行函数可以写函数名，但是因为它立即执行并执行完释放的特点，函数名没有什么用，所以一般不写

```js
(function foo() {
    console.log('foo');
})();
```

![](https://ws1.sinaimg.cn/large/006eYMu7ly1fu2h8ou3u2j30sd03wdfp.jpg)

可以看到，为了再次调用立即执行函数，我们给立即执行函数设置了名称，然而在立即执行函数执行过一次我们再调用它时，控制台报错，"foo is not defined"，这说明立即执行函数在执行完毕后就被释放了，所以再次调用就会报错



> 立即执行函数的实参写在最后的括号内

```js
(function (a) {
    console.log(a);
})(1);				// 1
```



> 以上定义形式只是 W3C 标准建议的声明形式，还有其他的声明形式

```js
// 立即执行函数写法的深入探究
// W3C建议写法： (function () {}())
// 其他写法：    (function () {})()
//              ! function () {}()
//              - function () {}()
//              + function () {}()
//              1 && function () {}()
//              0 || function () {}()
// 报错写法:     function() {}()
// 不报错但也不会执行的写法：
//              function fn(a,b,c) { console.log(a + b + c) }(1,2,3)
// 这种写法不报错的原因：因为系统在读到这条语句时，首先判断它不能按照立即执行函数
// 执行，然后系统就会找有没有其他可以解释这条语句的方法；系统会把这一个整体当做两
// 部分来看待 分别是 function fn(x) {} -----函数声明部分
//                  ('')              -----表达式部分
// 所以系统不会报错，而且因为前半部分是函数声明，没有被执行，后面表达式部分也不执
// 行，所以整个语句，既不报错，也不执行
// 注意，因为前半部分属于是函数声明，所以一定要有函数名，如果这里省略函数名的话会报错

// 原因：只有表达式才能被执行符号执行
```


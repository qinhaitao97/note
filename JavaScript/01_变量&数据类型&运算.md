---
title: 变量、数据类型、运算
date: 2018-05-01
categories:
  - JavaScript
tags:
  - JavaScript
top: false
---

![](https://ws1.sinaimg.cn/large/006eYMu7ly1fu786vw5ilj30eg0b1q3y.jpg)

# 变量

## 声明、赋值、初始化

声明，JS 中的变量用 `var` 关键词声明

```js
var a;
```

赋值，给变量赋予一定的值

```js
a = 1;
b = 'hello';
c = true;
```

初始化，在声明变量的同时，赋予变量一定的值

```js
var a = 1;
```

单一 var 模式，减少 var 的使用，对于一组变量声明，应当使用一个 var 进行声明

```js
// bad
var a;
var b;
var c;

// acceptable
var a, b, c;

// good for development
var a,
    b,
    c;
```

## 命名

命名规则

+ 区分大小写
+ 不允许使用 JavaScript 中的保留字，关键字
+ 可以包含英文字母、_、$、数字，但不能以数字开头

```js
//  区分大小写, a 和 A 是两个变量
var a;
var A;

// 不允许使用保留字、关键字，var 是声明关键字，不允许被当做变量使用
var var = 1;

// 可以包含英文字母、_、$、数字，但是不能以数字开头
var a1 = 1;		// 正确
var _a = 1;		// 正确
var $a = 1;		// 正确
var 1a = 1;		// 错误
```



# 数据类型

## 原始值

原始值采用 栈存储（stack），复制时生成副本，共有 6 中原始值类型：

```
- Number		// 数字
- String		// 字符串
- Boolean		// 布尔
- Undefined		// 未定义
- Null			// 不存在
- Symbol(ES6)	// 
```

## 引用值

引用值采用 堆存储（heap），复制时不生成副本，采用引用方式，常见的引用类型数据有：

```
- Array		// 数组
- Object	// 对象
- function	// 方法
- RegExp	// 正则
- Date()	// 日期
```



# 运算

## 运算符

### 数学运算符

```
+、-、*、/、%、=、()、++、--、+=、-=、*=、/=、%=

- 其中 '+' 运算符除了有数学运算的功能，还有字符串连接的功能
- 任何数据类型 + 字符串，结果都是字符串
```

### 比较运算符

```
>、<、==、===、>=、<=、!=

- '==='：绝对等于
```

### 逻辑运算符

```
&&、||、！

- &&：自左向右依次检查每一个表达式的运算结果的布尔值，若为真，则继续向后检查，若为假则停止检查，直到整个		与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果
- ||：自左向右依次检查每一个表达式的运算结果的布尔值，若为假，则继续向后检查，若为真则停止检查，直到整个		与运算表达式结束；返回结果为停止检查时，当前表达式的运算结果
- !： 将表达式的运算结果转换成布尔值再取反，值为true或false
```

```js
// 练习
var a = 1 && 2 + 3；
// a = 5;
var a = 0 && 2 + 3;
// a = 0;
var a = 1 || 2 + 3;
// a = 1;
var a = 0 || 2 + 3;
// a = 5;
var a = !1 + 1;
// a = 1;
var a = !0 + 1;
// a = 2;
var a = !(1 + 1)
// a = false;
var a = !0
// a = true;

// 应用
data && fn(data)

e = e || window.event
```



## 小数运算

### 精度

小数运算存在精度问题

```js
// 加法 =====================
// 0.1 + 0.2 = 0.30000000000000004
// 0.7 + 0.1 = 0.7999999999999999
// 0.2 + 0.4 = 0.6000000000000001
// 2.22 + 0.1 = 2.3200000000000003
 
// 减法 =====================
// 1.5 - 1.2 = 0.30000000000000004
// 0.3 - 0.2 = 0.09999999999999998
 
// 乘法 =====================
// 19.9 * 100 = 1989.9999999999998
// 19.9 * 10 * 10 = 1990
// 1306377.64 * 100 = 130637763.99999999
// 1306377.64 * 10 * 10 = 130637763.99999999
// 0.7 * 180 = 125.99999999999999
// 9.7 * 100 = 969.9999999999999
// 39.7 * 100 = 3970.0000000000005
 
// 除法 =====================
// 0.3 / 0.1 = 2.9999999999999996
// 0.69 / 10 = 0.06899999999999999
```

原因

JavaScript 中的数字采用 IEEE 754 的64为双精度标准，第 0 位表示符号位，1~11 位表示指数为，12~63 位表示小数位，符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度，IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位

以 `0.1 + 0.2` 为例，`0.1` 和 `0.2` 在被转换成二进制时，其浮点数用二进制表达是无穷的

```
0.1 -> 0.0001100110011001...(无限)
0.2 -> 0.0011001100110011...(无限)
```

IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为 

```
0.0100110011001100110011001100110011001100110011001100
```

因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 `0.30000000000000004`。所以在进行算术计算时会产生误差，[详细参考](https://github.com/camsong/blog/issues/9)

### 取整

向上取整

```js
Math.ceil()
```

向下取整

```js
Math.floor()
```

### 随机数

生成一个 (0, 1) 之间的随机数

```s
Math.random()
```

练习

随机生成 (0, 100) 之间的整数

```js
Math.floor(Math.random() * 100);
```

生成 [min, max] 之间的随机数

```js
Math.floor(Math.random() * (max - min + 1) + min)

parseInt(Math.random() * (max - min + 1) + min, 10)
```

### 处理位数

可以处理小数点前后 16 为的数据

